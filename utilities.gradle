/*
 * MIT License
 * 
 * Copyright (c) 2020 yaoyorozu
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

def task = { name ->
    { prj -> prj.tasks.findByPath(name) }
}


def hasPlugin = { name ->
    { prj -> prj.plugins.hasPlugin(name) }
}


project.ext.isJavaProject = {
    if (!it.file('src').exists()) {
        return
    }
    it.fileTree('.').matching { include 'src/*/java' }
}


project.ext.isGroovyProject = {
    if (!it.file('src').exists()) {
        return
    }
    it.fileTree('./src').matching { include 'src/*/groovy' }
}


project.ext.projectsHasTask = { name ->
    allprojects.findAll task(name)
}


project.ext.projectsHasPlugin = { name ->
    allprojects.findAll hasPlugin(name)
}


project.ext.allTasksBy = { name ->
    projectsHasTask(name).collect task(name)
}


ant.condition(property: "os", value: "windows") { os(family: "windows") }
ant.condition(property: "os", value: "unix"   ) { os(family: "unix"   ) }
class CrossPlatformCommand {
    Task task
    String osType
    CrossPlatformCommand(task, osType) {
        this.task = task
        this.osType = osType
    }
    def crossPFcommand(cmd) {
        switch(osType) {
        case 'windows':
            this.task.executable 'cmd'
            this.task.args += ['/c']

            if (new File("${cmd}.cmd").exists()) {
                this.task.args += ["${cmd}.cmd"]
            } else if (new File("${cmd}.bat").exists()) {
                this.task.args += ["${cmd}.bat"]
            } else {
                this.task.args += [cmd]
            }
            break
        case 'unix':
            if (new File("./${cmd}").exists()) {
                this.task.executable "./${cmd}"
            } else {
                this.task.executable "${cmd}"
            }
            break
        default:
            throw new IllegalArgumentException("Unsupported Operating System: ${osType}")
        }
    }
}
project.tasks.withType(Exec) { execTask ->
    execTask.convention.plugins.crossPlatformCommand = new CrossPlatformCommand(execTask, ant.properties['os'])
}


import org.gradle.internal.logging.text.StyledTextOutput
import org.gradle.internal.logging.text.StyledTextOutputFactory
import static org.gradle.internal.logging.text.StyledTextOutput.Style
class Console {
    def writer
    Console(writer) {
        this.writer = writer
    }
    def normal(message) {
        this.writer.style(Style.Normal).text(message)
        return this
    }
    def header(message) {
        this.writer.style(Style.Header).text(message)
        return this
    }
    def userInput(message) {
        this.writer.style(Style.UserInput).text(message)
        return this
    }
    def identifier(message) {
        this.writer.style(Style.Identifier).text(message)
        return this
    }
    def description(message) {
        this.writer.style(Style.Description).text(message)
        return this
    }
    def progressStatus(message) {
        this.writer.style(Style.ProgressStatus).text(message)
        return this
    }
    def success(message) {
        this.writer.style(Style.Success).text(message)
        return this
    }
    def successHeader(message) {
        this.writer.style(Style.SuccessHeader).text(message)
        return this
    }
    def failure(message) {
        this.writer.style(Style.Failure).text(message)
        return this
    }
    def failureHeader(message) {
        this.writer.style(Style.FailureHeader).text(message)
        return this
    }
    def info(message) {
        this.writer.style(Style.Info).text(message)
        return this
    }
    def error(message) {
        this.writer.style(Style.Error).text(message)
        return this
    }
}
project.ext.console = { new Console(services.get(StyledTextOutputFactory).create("${it}")) }
